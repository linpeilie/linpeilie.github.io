<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shiro教程]]></title>
    <url>%2Fcontent%2F2018%2F01%2F05%2FShiro%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;Shiro是Java的一个安全框架， 相对于Spring Security较为简单。Shiro不但可以用在JavaSE环境，也可以用在JavaEE环境。Shiro可以完成：认证、授权、加密、会话管理、与web继承、缓存等功能。 Shiro功能Authentication：身份认证、登陆，验证用户是不是拥有相应的身份。 Authentization：这个要注意，单词看上去与上面很像。这里指的是授权、即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做某件事情常见的如：验证某个用户是否拥有某个角色。或者验证某个用户对某个资源是否具有某个权限。 Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的， 也可以是Web环境的。 Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。 Web Support：Web支持，可以非常容易的集成到Web环境。 Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率。 Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。 Testing：提供测试支持。 Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。 Remember Me：记住我，非常常见的功能，即一次登录后，下次访问就不用登录了。 Shiro组件Subject：主体，可以看作是任何可以与应用交互的“用户”。这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject。如网络爬虫、机器人等。 SecurityManager：相当于SpringMVC中的DispatcherServlet，是Shiro的核心，所有具体的交互都通过SecurityManager进行控制；它管理着所有的Subject，且负责进行认证和授权、会话及缓存的管理。 Authenticator：认证器，负责主体认证 Authtizer：授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能。 Realm：域，Shiro从Realm获取安全数据（如用户、角色、权限），也就是说SecurityManager要验证身份，那么它需要从Realm获取相应的用户进行比较确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户身份是否合法；可以把Realm看作安全数据源。可以有一个或多个Realm。 SessionManager：管理Session的声明周期。 SessionDAO：数据访问对象，用户会话的CRUD CacheManager：缓存控制器，管理如用户、角色、权限等缓存，因为这些数据很少改变，所以放入缓存中提高访问的性能。 Cryptography：密码模块，提供了一些常见的加密组件用于密码加密/解密。 Shiro的认证流程身份验证身份验证：在应用中证明是本人，一般提供如他们的身份ID一些标识信息来进行身份验证，最常用如用户名/密码等在Shiro中，用户需要提供principals（身份）和credentials（证明）给shiro，从而验证用户身份。 principals：身份，即主体的标识数据，可以是任何东西，如用户名、邮箱、手机号等等，唯一即可credentials：证明/凭证，即只有用户本人知道的安全值，如密码等。 最长见的principals和credentials组合就是用户名/密码 基本认证流程1.把用户名和密码封装为UsernamePasswordToken对象2.执行登录，调用Subject的login()方法3.自定义Realm方法，从数据库中获取对应的记录，返回给Shiro4.由Shiro执行密码的对比 代码 1234567891011Subject currentUser = SecurityUtils.getSubject();if (!currentUser.isAuthenticated())&#123; logger.info("username : "+username+" | password : "+password); UsernamePasswordToken token = new UsernamePasswordToken(username,password); token.setRememberMe(true); try &#123; currentUser.login(token); &#125;catch (AuthenticationException ae)&#123; logger.error("登录失败 : "+ae.getMessage()); &#125;&#125; 自定义Realm实现1.继承AuthenticationInfo(仅能实现认证)或AuthorizingRealm(可实现认证和授权)2.重写doGetAuthenticationInfo方法3.把AuthenticationToken转换为UsernamePasswordToken4.从UsernamePasswordToken中获取username5.调用数据库的方法，从数据库中查询username对应的用户记录6.若用户不存在，则可以抛出UnknownAccountException异常7.根据用户信息的情况，决定是否需要抛出其他的AuthenticationException异常 常见子类：DisabledAccountException(账号禁用)LockedAcountException(账号锁定)UnknownAccountException(账号错误)ExcessiveAttemptsException(登录失败次数过多)8.根据用户的情况，来构建AuthenticationInfo对象并返回，通常使用的实现类为SimpleAuthentnInfo（从数据库中获取的数据）principal：认证的实体信息，可以是username，也可以是数据表对应的用户的实体类对象(例如User对象)credentials：密码（从数据库中获取的密码）realmName：当前realm对象的name，调用父类的getName()方法即可 代码 123456789101112131415161718@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; logger.info("开始获取身份验证信息"); String username = (String) authenticationToken.getPrincipal(); User user = userService.selectByUsername(username); if (user==null)&#123; logger.error("根据用户名:"+username+"没有找到账号"); throw new UnknownAccountException();//没找到账号 &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( user, user.getPassword(), ByteSource.Util.bytes(user.getSalt()), getName() ); return authenticationInfo;&#125; 身份授权&nbsp;&nbsp;&nbsp;&nbsp;访问控制，即在应用中控制谁能访问哪些资源(如访问页面/编辑数据/页面操作等)&nbsp;&nbsp;&nbsp;&nbsp;授权中几个关键对象：主体(Subject)、资源(Resource)、权限(Permission)、角色(Role) 主体(Subject):访问应用的用户，在Shiro中使用Subject代表该用户。 资源(Resource):在应用中用户可以访问的URL，比如访问jsp页面、查看/编辑某些数据、访问某个业务方法等等，用户只有授权后才能访问 权限(Permission):安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权利。即权限表示在应用中用户能不能访问某个资源。权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许。&nbsp;&nbsp;&nbsp;&nbsp;Shiro支持粗粒度权限(如用户模块的所有权限)和细粒度权限(操作某个用户的权限，是实例级别的) 角色(Role):权限的集合，一般情况下会赋予用户角色而不是权限， 这样用户可以拥有一组权限，赋予权限时比较方便 隐式角色：即直接通过角色来验证用户有没有操作权限。粒度是以角色为单位进行访问控制的，粒度较细粗；如果进行修改可能造成多处代码修改显式角色:在程序中通过权限控制谁能访问某个资源，假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修订多处代码；即粒度是以资源/实例为单位的；粒度较细 授权方式1.编程式：通过写if/else授权代码块完成。很少用 123456Subject subject = SecurityUtils.getSubject();if(subject.hasRole(“admin”))&#123;‘ //有权限&#125;else&#123; //无权限&#125; 2.注解式：通过在执行的Java方法上放置相应的注解完成，没有权限将抛出相应的异常1234@RequiresRoles(“admin”)public void hello()&#123; //有权限&#125; 3.jsp标签：在jsp页面通过相应的标签完成123&lt;shiro:hasRole name=”admin”&gt; &lt;!—有权限--&gt;&lt;/shiro:hasRole&gt; 基于角色的访问控制(隐式角色)Shiro提供了hasRole/hasAllRole用于判断用户是否拥有某个角色/某些权限；但是没有提供如hasAnyRole用于判断有某些权限中的某一个。Shiro提供的checkRole/checkRoles和hashRole/hasAllRoles不同的地方是它在判断为假的情况下会抛出UnauthorizedException异常。基于角色的访问控制(即隐式角色)缺点就是如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把所有相关的地方进行删除；这就是粗粒度造成的问题。基于资源的访问控制（显式角色）Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或所有权限。基于权限的访问控制，这种方法的一般规则是“资源标志符:操作，即是资源级别的粒度；这种方法的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但实现可能稍微复杂一些，需要维护”用户-角色，角色-权限(资源:操作)“之间的关系 授权流程 1.自定义Realm实现AuthorizingRealm，重写AuthorizationInfo方法2.从PrincipalCollection中获取登录用户的信息3.利用登录的用户的信息来查询用户当前的角色或权限(在数据库、配置文件中配置)4.创建SimpleAuthorizationInfo,并设置roles属性并返回 代码 123456789101112131415@Overrideprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; User user = (User) principalCollection.getPrimaryPrincipal(); if (user==null)&#123; logger.error("用户为空"); return null; &#125; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); Set&lt;String&gt; roles = userService.findRoles(user.getUsername()); authorizationInfo.setRoles(roles); Set&lt;String&gt; permissions = userService.findPermissions(user.getUsername()); authorizationInfo.setStringPermissions(permissions); return authorizationInfo;&#125; Shiro标签：1.guest:用户没有身份验证时显示相应信息，即游客访问信息 123&lt;shiro:guest&gt; 欢迎游客访问，&lt;a href=”login.jsp”&gt;登录&lt;/a&gt;&lt;/shiro:guest&gt; 2.user:用户已经经过认证/记住我登录后显示相应的信息 123&lt;shiro:user&gt; 欢迎[&lt;shiro:principal/&gt;]登录，&lt;a href=”logout”&gt;退出&lt;/a&gt;&lt;/shiro:user&gt; 3.authenticated:用户已经身份验证通过，即通过Subjet.login登录成功，不是记住我登录的 123&lt;shiro:authenticated&gt; 用户[&lt;shiro:principal/&gt;已身份验证通过&lt;/shiro:authenticated&gt; 4.notAuthenticated:用户未进行身份验证，即没有调用Subject.login进行登录，包括记住我自动登录也属于未进行身份验证 123&lt;shiro:notAuthenticated&gt; 未身份验证（包括记住我）&lt;/shiro:notAuthenticated&gt; 5.principal:显示用户身份信息，默认调用Subject.getPrincipal()获取，即Primary Principal 1&lt;shiro:principal property=”username”/&gt; 6.hasRole:如果当前Subject有角色将显示body体内内容 123&lt;shiro:hasRole name=”admin”&gt; 用户[&lt;shiro:principal/&gt;拥有角色 admin&lt;br/&gt;&lt;/shiro:hasRole&gt; 7.hasAnyRoles`_: 123&lt;shiro:hasRole name=”admin”&gt; 用户[&lt;shiro:principal/&gt;拥有角色 admin&lt;br/&gt;&lt;/shiro:hasRole&gt; 8.lacksRole:如果当前Subject没有角色将显示body体内容 123&lt;shiro:lacksRole name=”admin”&gt; 用户[&lt;shiro:principal/&gt;]没有角色admin&lt;br/&gt;&lt;/shiro:lackRole&gt; 权限注解 @RequiresAuthentication:表示当前Subject已经通过login进行了身份验证，即Subject.isAuthenticated()返回true @RequiresUser：表示当前Subject已经身份验证或者通过记住我登录的 @RequiresGuest：表示当前Subject没有身份验证或者通过记住我登录的，即是游客身份。 @RequiresRoles(value={“admin”,”user”},logical=Logical.AND)：表示当前Subject需要角色admin和user，如果将Logical.AND改为Logical.OR则表示需要角色admin或user 会话SessionShiro提供了完整的企业级会话管理工具，不依赖底层容器(如web容器tomcat),不管JavaSE还是JavaEE管径都可以使用,提供了会话管理、会话监听、会话存储/持久化、容器无关的集群、失效\过期支持、对web的透明支持、SSO单点登录的支持等特性。 相关方法： Subject.getSession():即可获取会话；其等价于Subject.getSession(true)，即如果当前没有Session对象会创建一个；Subject.getSession(false)，如果当前没有创建Session则返回nullsession.getId():获取当前会话的唯一标识session.getHost():获取当前Subject的主机地址session.getTimeout() &amp; session.setTimeout(毫秒):获取/设置当前Session的过期时间session.getStartTimestamp() &amp; session.setLastAccessTime():获取会话的启动时间及最后访问时间；如果是JavaEE应用需要自己定期调用session.touch()去更新最后的访问时间session.touch() &amp; session.stop():更新会话最后访问时间及销毁会话；当Subject.logout()时会自动调用stop()方法来销毁会话。如果在wb中，调用HttpSession.invalidate()也会自动调用Shiro Session.stop()方法进行销毁shiro的会话。session.setAttribute(key,value)session.getAttribute(key)session.removeAttribute(key) 集成Springweb.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--加载Spring--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-context-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--字符编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--springMVC--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--Shiro过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2Fcontent%2F2018%2F01%2F05%2FMarkdown%E8%AF%AD%E6%B3%95-1%2F</url>
    <content type="text"><![CDATA[Markdown：一种适应于网络的书写语言 标题语法在行首插入1到6个 #，对应标题1到6阶。 效果 # h1 ## h2 ### h3 #### h4 ##### h5 ###### h6 区块区块引用使用email形式的 &gt; 角括号 强调使用星号 * 和底线 _ 来标记需要强调的区段，两个效果相同 这行使用一个 *（斜体） 这行使用两个* （粗体） 这行使用一个 _（斜体） 这行使用两个_ （粗体） 列表无序列表语法 使用* 、+ 和 - 作为列表的项目标记，标记与文字之间需有一空格，效果相同 效果 星号列表 加号列表 减号列表 有序列表使用数字加一个英文句号作为项目标记 列表1 列表2 链接行内链接[] 里写链接文字，() 里写链接地址，() 中的&quot;&quot;中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的title文字。 语法 [链接文字](链接地址 &quot;链接标题&quot;) 效果 This is an example link This is an example.link 代码 This is an [example](http://example.com/)` This is an [example](http://example.com/ &quot;Title&quot;) ​ 参考链接一般用在学术论文上面，或者某一个链接在文章中多处使用，就可以对链接进行统一的管理 语法 [链接文字][链接标记] [链接标记]:链接地址 &quot;链接标题&quot; 注：如果链接文字本身可以作为链接标记，也可以写成 [链接标题][] [链接标题]:链接地址 效果 This is baidu 、google 、github 代码 This is [baidu][1] 、[google][google] 、[github][] [1]:http://www.baidu.com &quot;baidu&quot; [google]:http://www.google.com &quot;google&quot; [github]:http://www.github.com 自动链接以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是在 &lt;&gt; 中的就会自动转成链接。 效果 http://linpeilie.me 代码 &lt;http://linpeilie.me&gt; 图片图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。Alt：如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片Title：鼠标悬停于图片上时出现的文字,且位于图片下面注：Alt和Title都不是必须的，可以省略，但建议写上 行内式语法 ![图片Alt](图片地址 &quot;图片Title&quot;) 代码 ![头像](https://pic3.zhimg.com/50/v2-e2ae9159cf260da0ae61951bf1926abe_hd.jpg &quot;头像&quot;) 效果 参考式语法在文档要插入图片的地方写 ![图片Alt][标记] 在文档的最后写上 [标记]:图片地址 &quot;Title&quot; 代码 ![头像][avatar] [avatar]:https://pic3.zhimg.com/50/v2-e2ae9159cf260da0ae61951bf1926abe_hd.jpg &quot;头像&quot; 表格语法 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列与列之间用管道符 | 隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在 - 右边加上 :就右对齐 简单方式代码 姓名|性别|分数 -|-|- 张三|男|75 李四|女|93 王五|男|83 效果 姓名 性别 分数 张三 男 75 李四 女 93 王五 男 83 如果向右对齐则将第二列改为-|-: 原生方式代码 |姓名|性别|分数| |-|-|-| |张三|男|75| |李四|女|93| |王五|男|83| 效果 姓名 性别 分数 张三 男 75 李四 女 93 王五 男 83 代码插入程序代码的方式有两种：一种是利用缩进(Tab)，另一种是利用引号 ` 来标记代码区段。注：缩进式插入前档必须有空行 行内式代码 Java中的`String`类 效果 Java中的String类 缩进式缩进4个空格或是1个制表符 public static void main(String[] args){ System.out.print(&quot;Hello World&quot;); } 代码高亮可以在代码前后加三个反引号 `，并在后面声明代码为哪种语言 代码 ``` javapublic static void main(String[] args){ System.out.print(“Hello World”);}``` language可以 效果 123public static void main(String[] args)&#123; System.out.print("Hello World");&#125; HTML原始码在代码区块里面，&amp;、&lt;和&gt;会自动转成HTML实体，这样可以在Markdown中比较方便的插入HTML原始码 代码 &lt;div class=&quot;footer&quot;&gt; © 2004 Foo Corporation &lt;/div&gt; 效果 © 2004 Foo Corporation 代码 &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;王五&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 效果 值班人员 星期一 星期二 星期三 李强 张明 王平 转义在一些要正常显示其意义的符号前加\ 需要转义的字符 \ 反斜线` 反引号* 星号_ 底线{}花括号[] 方括号() 括号# 井号+ 加号- 减号. 英文句号! 感叹号]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fcontent%2F2017%2F12%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
